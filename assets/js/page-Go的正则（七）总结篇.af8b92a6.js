(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{498:function(s,n,a){"use strict";a.r(n);var e=a(1),t=Object(e.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"go-的正则-七-总结篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go-的正则-七-总结篇"}},[s._v("#")]),s._v(" Go 的正则（七）总结篇")]),s._v(" "),a("p",[s._v("上一个总结篇中，介绍了正则表达式如何变成一个语法树。本篇中主要介绍如何根据语法树生成状态机。")]),s._v(" "),a("p",[s._v("每一个状态对应一个指令。不同的指令可能有不同的操作。由于 Go 的实现中用了很多魔法，就不介绍具体的数据结构了。")]),s._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// It's kind of sleazy, but works well in practice.")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Go 源码：这有点恶心，但是很好用。")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("所有的指令放在一个数组中，新增加的指令只会附加在链表的最后。为了便于行文，还是引入一种假设的抽象数据结构用于描述指令。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Inst:\n  Op   // 指令类型\n  Next // 该指令后面的下一条指令\n  Rune // 用于字面量类，指令匹配的字符\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("语法树是一种树形结构，容易想到语法树到状态机的转换可以使用递归形式的算法。但是指令全部存放在一个“全局”的数组中，所以 caller 需要 callee 返回一些信息，以便于把多段指令连接起来。这个数据结构就是 "),a("code",[s._v("frag")]),s._v(" 。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("frag:\n  start    // 第一条指令的位置\n  ll_start // 链表头的位置\n  ll_end   // 链表尾的位置\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("关于链表是什么，暂时先不描述。在转换的一开始，指令数组中就插入了一条指令：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op      | Next | Rune\n------+---------+------+------\n[0]    InstFail  -      -\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[a("code",[s._v("InstFail")]),s._v(" 是一条返回失败结果的指令。当状态机运行到这个状态时，说明不匹配。")]),s._v(" "),a("h2",{attrs:{id:"字面量和字符类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字面量和字符类"}},[s._v("#")]),s._v(" 字面量和字符类")]),s._v(" "),a("p",[s._v("类型为 "),a("code",[s._v("OpLiteral")]),s._v(" 、 "),a("code",[s._v("OpCharClass")]),s._v(" 、 "),a("code",[s._v("OpAnyCharNotNL")]),s._v(" 、 "),a("code",[s._v("OpAnyChar")]),s._v(" 的节点转换起来最为简单。")]),s._v(" "),a("p",[s._v("每个指令只匹配一个字符，所以一共有 4 种对应的指令。第一种是 "),a("code",[s._v("InstRune1")]),s._v(" ，匹配一个字符。 "),a("code",[s._v("OpLiteral")]),s._v(" 类型的字面量会按字符分割成对应数量的指令。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("OpLiteral: \"abc\"\n\nInst: InstRune1, 'a'\nInst: InstRune1, 'b'\nInst: InstRune1, 'c'\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("其他三种指令分别与节点类型构成对应关系： "),a("code",[s._v("OpCharClass")]),s._v(" 变为 "),a("code",[s._v("InstRune")]),s._v(" ， "),a("code",[s._v("OpAnyCharNotNL")]),s._v(" 变为 "),a("code",[s._v("InstAnyCharNotNL")]),s._v(" ， "),a("code",[s._v("OpAnyChar")]),s._v(" 变为 "),a("code",[s._v("InstAnyChar")]),s._v(" 。")]),s._v(" "),a("h2",{attrs:{id:"连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连接"}},[s._v("#")]),s._v(" 连接")]),s._v(" "),a("p",[s._v("类型为 "),a("code",[s._v("OpConcat")]),s._v(" 的节点的子节点产生的指令需要被连接起来。另外， "),a("code",[s._v("OpLiteral")]),s._v(" 类型的节点，如果产生的指令数量大于 1 ，那么也需要被连接起来。接下来以正则表达式 "),a("code",[s._v("ab")]),s._v(" 为例。")]),s._v(" "),a("p",[s._v("首次插入了字符 "),a("code",[s._v("a")]),s._v(" 。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  -      'a'\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("负责插入 "),a("code",[s._v("a")]),s._v(" 的方法会返回一个 "),a("code",[s._v("frag")]),s._v(" ，用于描述插入的指令片段的相关信息。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("frag_a:\n  start:    1\n  ll_start: 1\n  ll_end:   1\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[a("code",[s._v("frag")]),s._v(" 的 "),a("code",[s._v("start")]),s._v(" 指令，指向该片段的第一条指令，也就是入口。而 "),a("code",[s._v("ll_")]),s._v(" 开头的字段描述的是一个链表。链表中保存的是这段指令的所有出口。显然， "),a("code",[s._v("InstRune1")]),s._v(" 类型的指令只会有一个出口。")]),s._v(" "),a("p",[s._v("然后 "),a("code",[s._v("b")]),s._v(" 被插入到数组中。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  -      'a'\n[2]    InstRune1  -      'b'\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("与 "),a("code",[s._v("b")]),s._v(" 相关的 "),a("code",[s._v("frag")]),s._v(" 是：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("frag_b:\n  start:    2\n  ll_start: 2\n  ll_end:   2\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("显然 "),a("code",[s._v("frag_a")]),s._v(" 的所有出口都要连接到 "),a("code",[s._v("frag_b")]),s._v(" 的入口。伪代码如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("target = frag_b.start\n\nptr = frag_a.ll_start\nwhile ptr != 0:\n  inst = Inst[ptr]\n  ptr = inst.Next\n  inst.Next = target\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[a("code",[s._v("target")]),s._v(" 就是 "),a("code",[s._v("b")]),s._v(" 的入口。前面已经提到， "),a("code",[s._v("ll")]),s._v(" 指的是链表。所以使用循环变量 "),a("code",[s._v("ptr")]),s._v(" ，初始时指向链表头 "),a("code",[s._v("frag_a.ll_start")]),s._v(" 。该链表也是通过 "),a("code",[s._v("Inst")]),s._v(" 的 "),a("code",[s._v("Next")]),s._v(" 字段连接的。所以一边令 "),a("code",[s._v("ptr")]),s._v(" 指向下一个位置，一边把当前指令的 "),a("code",[s._v("Next")]),s._v(" 修改为 "),a("code",[s._v("target")]),s._v(" 。")]),s._v(" "),a("p",[s._v("合并完成后，数组变为：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  -      'b'\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("返回的 "),a("code",[s._v("frag")]),s._v(" 是：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("frag:\n  start:    1\n  ll_start: 2\n  ll_end:   2\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("如果后面再插入 "),a("code",[s._v("c")]),s._v(" ，那么：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  3      'b'\n[3]    InstRune1  -      'c'\n\nfrag:\n  start:    1\n  ll_start: 3\n  ll_end:   3\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("连接操作是比较简单的。")]),s._v(" "),a("h2",{attrs:{id:"选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#选择"}},[s._v("#")]),s._v(" 选择")]),s._v(" "),a("p",[s._v("类型为 "),a("code",[s._v("OpAlternate")]),s._v(" 的节点的子节点产生的指令需要被选择起来。还是用例子来讲解，比如 "),a("code",[s._v("ab|cd|ef")]),s._v(" 。")]),s._v(" "),a("p",[s._v("该 "),a("code",[s._v("OpAlternate")]),s._v(" 有三个子节点，分别是 "),a("code",[s._v("ab")]),s._v(" 、 "),a("code",[s._v("cd")]),s._v(" 和 "),a("code",[s._v("ef")]),s._v(" 。首先是 "),a("code",[s._v("ab")]),s._v(" ，这正好是"),a("a",{attrs:{href:"#%E8%BF%9E%E6%8E%A5"}},[s._v("连接")]),s._v("中使用的例子，其结果是：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  -      'b'\n\nfrag_1:\n  start:    1\n  ll_start: 2\n  ll_end:   2\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("接下来递归地处理第二个子节点 "),a("code",[s._v("cd")]),s._v(" ：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  -      'b'\n[3]    InstRune1  4      'c'\n[4]    InstRune1  -      'd'\n\nfrag_2:\n  start:    3\n  ll_start: 4\n  ll_end:   4\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[s._v("这时候有了两个分支，需要聚合一下。注意在指令系统中，除了 "),a("code",[s._v("InstAlt")]),s._v(" 之外的所有指令都只有一个出口 "),a("code",[s._v("Next")]),s._v(" ，而 "),a("code",[s._v("InstAlt")]),s._v(" 可以有两个出口。")]),s._v(" "),a("p",[s._v("在把 "),a("code",[s._v("frag_1")]),s._v(" 和 "),a("code",[s._v("frag_2")]),s._v(" 选择到一起时，一个 "),a("code",[s._v("InstAlt")]),s._v(" 指令将先被插入数组，其两个出口分别是 "),a("code",[s._v("ab")]),s._v(" 和 "),a("code",[s._v("cd")]),s._v(" 这两个分支。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  -      'b'\n[3]    InstRune1  4      'c'\n[4]    InstRune1  -      'd'\n[5]    InstAlt    1, 3   -\n\nfrag_alt_1:\n  start: 5\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("注意 "),a("code",[s._v("frag_alt_1")]),s._v(" 的出口还没有写好。显然， "),a("code",[s._v("frag_alt_1")]),s._v(" 的出口等于 "),a("code",[s._v("frag_1")]),s._v(" 的所有出口和 "),a("code",[s._v("frag_2")]),s._v(" 的所有出口构成的集合。此时，只需要把对应的两个链表连接起来即可。")]),s._v(" "),a("p",[a("code",[s._v("frag_1")]),s._v(" 的链表结束位置 "),a("code",[s._v("ll_end")]),s._v(" 是 2 ，而 "),a("code",[s._v("frag_2")]),s._v(" 的链表开始位置是 "),a("code",[s._v("ll_start")]),s._v(" 是 4 。因此让 "),a("code",[s._v("Inst[frag_1.ll_end].Next = frag_2.ll_head")]),s._v(" 即可。最后，把新链表的头尾信息保存到 "),a("code",[s._v("frag_alt_1")]),s._v(" 中。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  (4)    'b'\n[3]    InstRune1  4      'c'\n[4]    InstRune1  -      'd'\n[5]    InstAlt    1, 3   -\n\nfrag_alt_1:\n  start:    5\n  ll_start: 2\n  ll_end:   4\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[a("code",[s._v("(4)")]),s._v(" 表示这不是真的下一条指令，而是一个链表。链表上的所有指令，都是处于同一个层次的出口，这些出口需要被写上真正的出口索引。接下来，进入了第三个子节点 "),a("code",[s._v("ef")]),s._v(" 。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  (4)    'b'\n[3]    InstRune1  4      'c'\n[4]    InstRune1  -      'd'\n[5]    InstAlt    1, 3   -\n[6]    InstRune1  7      'e'\n[7]    InstRune1  -      'f'\n\nfrag_3:\n  start:    6\n  ll_start: 7\n  ll_end:   7\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("p",[s._v("然后 "),a("code",[s._v("frag_alt_1")]),s._v(" 将会和 "),a("code",[s._v("frag_3")]),s._v(" 选择到一起。还是先插入 "),a("code",[s._v("InstAlt")]),s._v(" 指令，然后连接链表。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  (4)    'b'\n[3]    InstRune1  4      'c'\n[4]    InstRune1  (7)    'd'\n[5]    InstAlt    1, 3   -\n[6]    InstRune1  7      'e'\n[7]    InstRune1  -      'f'\n[8]    InstAlt    5, 6   -\n\nfrag_alt_2:\n  start:    8\n  ll_start: 2\n  ll_end:   7\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("p",[s._v("那么整个树就处理完了。处理完整个语法树后，转换程序会插入一个 "),a("code",[s._v("InstMatch")]),s._v(" 指令，代表匹配成功，然后把剩余的出口都连接到它。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  9      'b'\n[3]    InstRune1  4      'c'\n[4]    InstRune1  9      'd'\n[5]    InstAlt    1, 3   -\n[6]    InstRune1  7      'e'\n[7]    InstRune1  9      'f'\n[8]    InstAlt    5, 6   -\n[9]    InstMatch  -      -\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[s._v("这样，语法树就转换成了指令数组，也就是状态机（NFA）。")]),s._v(" "),a("h2",{attrs:{id:"重复"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重复"}},[s._v("#")]),s._v(" 重复")]),s._v(" "),a("p",[s._v("重复有三种， "),a("code",[s._v("x*")]),s._v(" 、 "),a("code",[s._v("x+")]),s._v(" 、 "),a("code",[s._v("x?")]),s._v(" 。还有一个特殊一点的， "),a("code",[s._v("x{m,n}")]),s._v(" ，在处理语法树的节点会被优化成以上三种重复。")]),s._v(" "),a("ol",[a("li",[s._v("至少重复 "),a("code",[s._v("m")]),s._v(" 次： "),a("code",[s._v("x{m,}")]),s._v(" 类型的重复，会被改写成 "),a("code",[s._v("xxx...xxx*")]),s._v(" 形式。")]),s._v(" "),a("li",[s._v("至多重复 "),a("code",[s._v("n")]),s._v(" 次： "),a("code",[s._v("x{n}")]),s._v(" 类型的重复，会被改写成 "),a("code",[s._v("x(x(x(...)?)?)?")]),s._v(" 形式。")]),s._v(" "),a("li",[s._v("同时有至少和至多的条件： "),a("code",[s._v("x{m,n}")]),s._v(" 类型的重复，会被改写成 "),a("code",[s._v("xxx...xxx(x(x(...)?)?)?")]),s._v(" 形式。")])]),s._v(" "),a("p",[s._v("所以只需要解决 "),a("code",[s._v("x*")]),s._v(" 、 "),a("code",[s._v("x+")]),s._v(" 、 "),a("code",[s._v("x?")]),s._v(" 这三种形式就行了。在这三种形式中，全都是先把需要重复的部分先进行转换。我们还是以 "),a("code",[s._v("ab|cd|ef")]),s._v(" 作为例子，分别是 "),a("code",[s._v("(ab|cd|ef)*")]),s._v(" 、 "),a("code",[s._v("(ab|cd|ef)+")]),s._v(" 、 "),a("code",[s._v("(ab|cd|ef)?")]),s._v(" 。子表达式 "),a("code",[s._v("ab|cd|ef")]),s._v(" 处理完之后：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  (4)    'b'\n[3]    InstRune1  4      'c'\n[4]    InstRune1  (7)    'd'\n[5]    InstAlt    1, 3   -\n[6]    InstRune1  7      'e'\n[7]    InstRune1  -      'f'\n[8]    InstAlt    5, 6   -\n\nfrag:\n  start:    8\n  ll_start: 2\n  ll_end:   7\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("p",[a("code",[s._v("*")]),s._v(" 很简单，插入一个 "),a("code",[s._v("InstAlt")]),s._v(" 指令，一个出口指向 "),a("code",[s._v("frag")]),s._v(" 的入口，另一个出口留着返回给 "),a("code",[s._v("caller")]),s._v(" 。另外， "),a("code",[s._v("frag")]),s._v(" 的出口需要被连接到 "),a("code",[s._v("InstAlt")]),s._v(" 的入口。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  9      'b'\n[3]    InstRune1  4      'c'\n[4]    InstRune1  9      'd'\n[5]    InstAlt    1, 3   -\n[6]    InstRune1  7      'e'\n[7]    InstRune1  9      'f'\n[8]    InstAlt    5, 6   -\n[9]    InstAlt    -, 8   -\n\nfrag:\n  start:    9\n  ll_start: 9\n  ll_end:   9\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br")])]),a("p",[a("code",[s._v("+")]),s._v(" 更简单了，和 "),a("code",[s._v("*")]),s._v(" 几乎一样，只是返回 "),a("code",[s._v("frag")]),s._v(" 不同而已。在 "),a("code",[s._v("+")]),s._v(" 中， "),a("code",[s._v("frag.start")]),s._v(" 是需要被重复的子表达式的入口，因此子表达式必须先被匹配一次，才能到达新插入的 "),a("code",[s._v("InstAlt")]),s._v(" 。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("frag:\n  start:    8\n  ll_start: 9\n  ll_end:   9\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[a("code",[s._v("?")]),s._v(" 也很简单，和 "),a("code",[s._v("*")]),s._v(" 几乎一样，只是返回 "),a("code",[s._v("frag")]),s._v(" 不同而已。在 "),a("code",[s._v("?")]),s._v(" 中，子表达式的出口不需要被连接到 "),a("code",[s._v("InstAlt")]),s._v(" 的入口，而是和 "),a("code",[s._v("InstAlt")]),s._v(" 的一个出口放到一起，返回给 caller 。 "),a("code",[s._v("InstAlt")]),s._v(" 的另一个出口还是会连接到子表达式的入口。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("index | Op       | Next | Rune\n------+----------+------+------\n[0]    InstFail   -      -\n[1]    InstRune1  2      'a'\n[2]    InstRune1  (4)    'b'\n[3]    InstRune1  4      'c'\n[4]    InstRune1  (7)    'd'\n[5]    InstAlt    1, 3   -\n[6]    InstRune1  7      'e'\n[7]    InstRune1  (9)    'f'\n[8]    InstAlt    5, 6   -\n[9]    InstAlt    -, 8   -\n\nfrag:\n  start:    9\n  ll_start: 2\n  ll_end:   9\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br")])]),a("h2",{attrs:{id:"最后"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[s._v("#")]),s._v(" 最后")]),s._v(" "),a("p",[s._v("最后 NFA 生成了，现在还有几个问题。第一，在 tokenizer 中，不恰当的 token 定义会导致 tokenizer 每次产生 token 都要扫描全部输入。举个例子来说：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("a*b { return 0; }\na   { return 1; }\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("此时如果输入是大量的 "),a("code",[s._v("a")]),s._v(" ，比如说十万个 "),a("code",[s._v("a")]),s._v(" ：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n...\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[a("code",[s._v("a*b")]),s._v(" 只有在扫描完整个文件之后，才会得到明确的 reject 结果，导致 tokenizer 的性能大幅降低。")]),s._v(" "),a("p",[s._v("这是 tokenizer 的问题。在正则中，匹配不一定是从文本开头起始的。比如 "),a("code",[s._v("aaab")]),s._v(" 可以匹配到 "),a("code",[s._v("aabaabaabaaabaabaabaab")]),s._v(" 之中的某一部分，这些都是怎么实现的呢？")]),s._v(" "),a("p",[s._v("就看状态机是如何被模拟的了。")]),s._v(" "),a("p",[s._v("这个总结篇也略去了一些细节。比如生成状态机时，还会调用一些函数，试图生成 One-Pass 属性的指令数组，这类指令数组具有 DFA 的性质，能够消除 NFA 中的歧义性。但是值得被转化为 DFA 的正则表达式不多，首先，它必须是 "),a("code",[s._v("^...$")]),s._v(" 形式的；其次，指令数量不能超过 1000 条，不然就不值得转换了。")]),s._v(" "),a("p",[s._v("消除 NFA 中的歧义性的方法是构造各个分支的 First 集合。一般来说很难成功，例如 "),a("code",[s._v("ab|ac")]),s._v(" 这样的正则表达式，由于两个分支都是 "),a("code",[s._v("a")]),s._v(" 开头，那么遇到 "),a("code",[s._v("a")]),s._v(" 时根本不知道选择哪一个分支。")]),s._v(" "),a("p",[s._v("总而言之，这一篇结束了，下一个总结篇应该是如何模拟状态机运行了。")])])}),[],!1,null,null,null);n.default=t.exports}}]);